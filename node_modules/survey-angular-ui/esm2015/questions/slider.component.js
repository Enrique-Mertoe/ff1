import { Component, ViewChild } from "@angular/core";
import { QuestionAngular } from "../question";
import { AngularComponentFactory } from "../component-factory";
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "../utils/dynamic.directive";
export class SliderQuestionComponent extends QuestionAngular {
    ngAfterViewInit() {
        super.ngAfterViewInit();
        if (this.model && this.rangeInputElement) {
            this.model.refreshInputRange(this.rangeInputElement);
        }
    }
    get rootRef() {
        var _a;
        return (_a = this.elementContentRef) === null || _a === void 0 ? void 0 : _a.nativeElement;
    }
    get rangeInputElement() {
        var _a;
        return (_a = this.rangeInputRef) === null || _a === void 0 ? void 0 : _a.nativeElement;
    }
    get labelCountArray() {
        const result = [];
        for (let i = 0; i < this.model.renderedLabelCount; i++) {
            result.push(i);
        }
        return result;
    }
    get valueArray() {
        return this.model.renderedValue;
    }
    trackByRenderedValue(i) {
        return i;
    }
    trackByLabelCount(i, label) {
        return label.id;
    }
}
SliderQuestionComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: SliderQuestionComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
SliderQuestionComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: SliderQuestionComponent, selector: "sv-ng-slider-question", viewQueries: [{ propertyName: "rangeInputRef", first: true, predicate: ["rangeInputRef"], descendants: true }], usesInheritance: true, ngImport: i0, template: "\n<div [class]=\"model.rootCss\" #contentElement>\n  <input *ngIf=\"model.sliderType !== 'single' && model.allowDragRange\" #rangeInputRef\n  name=\"range-input\" [class]=\"model.cssClasses.input\" type=\"range\" tabIndex=\"-1\"\n  id=\"sjs-slider-input-range-input\"\n  [attr.min]=\"model.min\" [attr.max]=\"model.max\" [attr.step]=\"model.step\" aria-hidden=\"true\"\n  (input)=\"model.handleRangeOnChange($any($event))\"\n  (pointerdown)=\"model.handleRangePointerDown($any($event), rootRef)\"\n  (pointerup)=\"model.handleRangePointerUp($any($event), rangeInputRef)\" />\n  \n  <div [class]=\"model.cssClasses.visualContainer\" (pointerup)=\"model.setValueByClickOnPath($any($event), rootRef)\">\n    <div [class]=\"model.cssClasses.visualContainerSlider\">\n      <div [class]=\"model.cssClasses.inverseTrackLeft\" [style]=\"{ width: model.getTrackPercentLeft() + '%' }\"></div>\n      <div [class]=\"model.cssClasses.inverseTrackRight\" [style]=\"{ width: model.getTrackPercentRight() + '%' }\"></div>\n      <div [class]=\"model.cssClasses.rangeTrack\" [style]=\"{ left: model.getTrackPercentLeft() + '%', right: model.getTrackPercentRight() + '%' }\" ></div>\n\n       <ng-container *ngFor=\"let value of valueArray; index as i; trackBy: trackByRenderedValue;\">\n        <input [class]=\"model.cssClasses.input\" [attr.id]=\"'sjs-slider-input-' + i\" type=\"range\" [value]=\"value\" \n          [attr.min]=\"model.min\" [attr.max]=\"model.max\" [attr.step]=\"model.step\" [disabled]=\"model.isDisabledAttr\"\n          (input)=\"model.handleOnChange($any($event), i)\"\n          (pointerdown)=\"model.handlePointerDown($any($event))\"\n          (pointerup)=\"model.handlePointerUp($any($event))\"\n          (keydown)=\"model.handleKeyDown($any($event))\"\n          (keyup)=\"model.handleKeyUp($any($event))\"\n          (focus)=\"model.handleOnFocus(i)\"\n          (blur)=\"model.handleOnBlur()\"\n          [attr.aria-required]=\"model.a11y_input_ariaRequired\"\n          [attr.aria-label]=\"model.a11y_input_ariaLabel\"\n          [attr.aria-labelledby]=\"model.a11y_input_ariaLabelledBy\"\n          [attr.aria-describedby]=\"model.a11y_input_ariaDescribedBy\"\n          [attr.aria-invalid]=\"model.a11y_input_ariaInvalid\"\n          [attr.aria-errormessage]=\"model.a11y_input_ariaErrormessage\"\n        />\n        <div [class]=\"model.getThumbContainerCss(i)\" [style]=\"{ left: model.getPercent(value) + '%' }\">\n          <div *ngIf=\"model.tooltipVisibility !== 'never'\" [class]=\"model.tooltipCss\">\n            <div [class]=\"model.cssClasses.tooltipPanel\">\n              <div [class]=\"model.cssClasses.tooltipValue\">{{model.getTooltipValue(i)}}</div>\n            </div>\n          </div>\n          <div [class]=\"model.cssClasses.thumb\">\n            <div [class]=\"model.cssClasses.thumbDot\"></div>\n          </div>\n        </div>\n      </ng-container>\n\n    </div>\n  </div>\n\n  <div *ngIf=\"model.showLabels\" [class]=\"model.cssClasses.labelsContainer\">\n    <div>\n      <ng-template *ngFor=\"let label of model.renderedLabels; index as i; trackBy: trackByLabelCount;\" [component]=\"{ name: 'sv-slider-label-item', data: {model: model, item: label }}\"></ng-template>\n    </div>\n  </div>\n</div>\n", directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2.DynamicComponentDirective, selector: "[component]", inputs: ["component"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: SliderQuestionComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "sv-ng-slider-question",
                    templateUrl: "./slider.component.html"
                }]
        }], propDecorators: { rangeInputRef: [{
                type: ViewChild,
                args: ["rangeInputRef"]
            }] } });
AngularComponentFactory.Instance.registerComponent("slider-question", SliderQuestionComponent);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9xdWVzdGlvbnMvc2xpZGVyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uL3NyYy9xdWVzdGlvbnMvc2xpZGVyLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQWMsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2pFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFFOUMsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sc0JBQXNCLENBQUM7Ozs7QUFNL0QsTUFBTSxPQUFPLHVCQUF3QixTQUFRLGVBQW9DO0lBR3RFLGVBQWU7UUFDdEIsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3hCLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDeEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztTQUN0RDtJQUNILENBQUM7SUFDRCxJQUFJLE9BQU87O1FBQ1QsT0FBTyxNQUFBLElBQUksQ0FBQyxpQkFBaUIsMENBQUUsYUFBYSxDQUFDO0lBQy9DLENBQUM7SUFDRCxJQUFJLGlCQUFpQjs7UUFDbkIsT0FBTyxNQUFBLElBQUksQ0FBQyxhQUFhLDBDQUFFLGFBQWEsQ0FBQztJQUMzQyxDQUFDO0lBQ0QsSUFBSSxlQUFlO1FBQ2pCLE1BQU0sTUFBTSxHQUFZLEVBQUUsQ0FBQztRQUMzQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN0RCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2hCO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUNELElBQUksVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUM7SUFDbEMsQ0FBQztJQUNELG9CQUFvQixDQUFFLENBQVM7UUFDN0IsT0FBTyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBQ0QsaUJBQWlCLENBQUUsQ0FBUyxFQUFFLEtBQWdCO1FBQzVDLE9BQU8sS0FBSyxDQUFDLEVBQUUsQ0FBQztJQUNsQixDQUFDOztxSEE5QlUsdUJBQXVCO3lHQUF2Qix1QkFBdUIsb01DVHBDLHVyR0FzREE7NEZEN0NhLHVCQUF1QjtrQkFKbkMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsdUJBQXVCO29CQUNqQyxXQUFXLEVBQUUseUJBQXlCO2lCQUN2Qzs4QkFFNkIsYUFBYTtzQkFBeEMsU0FBUzt1QkFBQyxlQUFlOztBQWdDNUIsdUJBQXVCLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLGlCQUFpQixFQUFFLHVCQUF1QixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIFZpZXdDaGlsZCB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBRdWVzdGlvbkFuZ3VsYXIgfSBmcm9tIFwiLi4vcXVlc3Rpb25cIjtcbmltcG9ydCB7IEl0ZW1WYWx1ZSwgUXVlc3Rpb25TbGlkZXJNb2RlbCB9IGZyb20gXCJzdXJ2ZXktY29yZVwiO1xuaW1wb3J0IHsgQW5ndWxhckNvbXBvbmVudEZhY3RvcnkgfSBmcm9tIFwiLi4vY29tcG9uZW50LWZhY3RvcnlcIjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiBcInN2LW5nLXNsaWRlci1xdWVzdGlvblwiLFxuICB0ZW1wbGF0ZVVybDogXCIuL3NsaWRlci5jb21wb25lbnQuaHRtbFwiXG59KVxuZXhwb3J0IGNsYXNzIFNsaWRlclF1ZXN0aW9uQ29tcG9uZW50IGV4dGVuZHMgUXVlc3Rpb25Bbmd1bGFyPFF1ZXN0aW9uU2xpZGVyTW9kZWw+IHtcbiAgQFZpZXdDaGlsZChcInJhbmdlSW5wdXRSZWZcIikgcmFuZ2VJbnB1dFJlZiE6IEVsZW1lbnRSZWY8SFRNTElucHV0RWxlbWVudD47XG5cbiAgb3ZlcnJpZGUgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHN1cGVyLm5nQWZ0ZXJWaWV3SW5pdCgpO1xuICAgIGlmICh0aGlzLm1vZGVsICYmIHRoaXMucmFuZ2VJbnB1dEVsZW1lbnQpIHtcbiAgICAgIHRoaXMubW9kZWwucmVmcmVzaElucHV0UmFuZ2UodGhpcy5yYW5nZUlucHV0RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGdldCByb290UmVmKCk6IEhUTUxFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50Q29udGVudFJlZj8ubmF0aXZlRWxlbWVudDtcbiAgfVxuICBnZXQgcmFuZ2VJbnB1dEVsZW1lbnQoKTogSFRNTElucHV0RWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VJbnB1dFJlZj8ubmF0aXZlRWxlbWVudDtcbiAgfVxuICBnZXQgbGFiZWxDb3VudEFycmF5KCk6IG51bWJlcltdIHtcbiAgICBjb25zdCByZXN1bHQ6bnVtYmVyW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubW9kZWwucmVuZGVyZWRMYWJlbENvdW50OyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldCB2YWx1ZUFycmF5KCk6IG51bWJlcltdIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5yZW5kZXJlZFZhbHVlO1xuICB9XG4gIHRyYWNrQnlSZW5kZXJlZFZhbHVlIChpOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBpO1xuICB9XG4gIHRyYWNrQnlMYWJlbENvdW50IChpOiBudW1iZXIsIGxhYmVsOiBJdGVtVmFsdWUpOiBzdHJpbmcge1xuICAgIHJldHVybiBsYWJlbC5pZDtcbiAgfVxufVxuXG5Bbmd1bGFyQ29tcG9uZW50RmFjdG9yeS5JbnN0YW5jZS5yZWdpc3RlckNvbXBvbmVudChcInNsaWRlci1xdWVzdGlvblwiLCBTbGlkZXJRdWVzdGlvbkNvbXBvbmVudCk7IiwiXG48ZGl2IFtjbGFzc109XCJtb2RlbC5yb290Q3NzXCIgI2NvbnRlbnRFbGVtZW50PlxuICA8aW5wdXQgKm5nSWY9XCJtb2RlbC5zbGlkZXJUeXBlICE9PSAnc2luZ2xlJyAmJiBtb2RlbC5hbGxvd0RyYWdSYW5nZVwiICNyYW5nZUlucHV0UmVmXG4gIG5hbWU9XCJyYW5nZS1pbnB1dFwiIFtjbGFzc109XCJtb2RlbC5jc3NDbGFzc2VzLmlucHV0XCIgdHlwZT1cInJhbmdlXCIgdGFiSW5kZXg9XCItMVwiXG4gIGlkPVwic2pzLXNsaWRlci1pbnB1dC1yYW5nZS1pbnB1dFwiXG4gIFthdHRyLm1pbl09XCJtb2RlbC5taW5cIiBbYXR0ci5tYXhdPVwibW9kZWwubWF4XCIgW2F0dHIuc3RlcF09XCJtb2RlbC5zdGVwXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgKGlucHV0KT1cIm1vZGVsLmhhbmRsZVJhbmdlT25DaGFuZ2UoJGFueSgkZXZlbnQpKVwiXG4gIChwb2ludGVyZG93bik9XCJtb2RlbC5oYW5kbGVSYW5nZVBvaW50ZXJEb3duKCRhbnkoJGV2ZW50KSwgcm9vdFJlZilcIlxuICAocG9pbnRlcnVwKT1cIm1vZGVsLmhhbmRsZVJhbmdlUG9pbnRlclVwKCRhbnkoJGV2ZW50KSwgcmFuZ2VJbnB1dFJlZilcIiAvPlxuICBcbiAgPGRpdiBbY2xhc3NdPVwibW9kZWwuY3NzQ2xhc3Nlcy52aXN1YWxDb250YWluZXJcIiAocG9pbnRlcnVwKT1cIm1vZGVsLnNldFZhbHVlQnlDbGlja09uUGF0aCgkYW55KCRldmVudCksIHJvb3RSZWYpXCI+XG4gICAgPGRpdiBbY2xhc3NdPVwibW9kZWwuY3NzQ2xhc3Nlcy52aXN1YWxDb250YWluZXJTbGlkZXJcIj5cbiAgICAgIDxkaXYgW2NsYXNzXT1cIm1vZGVsLmNzc0NsYXNzZXMuaW52ZXJzZVRyYWNrTGVmdFwiIFtzdHlsZV09XCJ7IHdpZHRoOiBtb2RlbC5nZXRUcmFja1BlcmNlbnRMZWZ0KCkgKyAnJScgfVwiPjwvZGl2PlxuICAgICAgPGRpdiBbY2xhc3NdPVwibW9kZWwuY3NzQ2xhc3Nlcy5pbnZlcnNlVHJhY2tSaWdodFwiIFtzdHlsZV09XCJ7IHdpZHRoOiBtb2RlbC5nZXRUcmFja1BlcmNlbnRSaWdodCgpICsgJyUnIH1cIj48L2Rpdj5cbiAgICAgIDxkaXYgW2NsYXNzXT1cIm1vZGVsLmNzc0NsYXNzZXMucmFuZ2VUcmFja1wiIFtzdHlsZV09XCJ7IGxlZnQ6IG1vZGVsLmdldFRyYWNrUGVyY2VudExlZnQoKSArICclJywgcmlnaHQ6IG1vZGVsLmdldFRyYWNrUGVyY2VudFJpZ2h0KCkgKyAnJScgfVwiID48L2Rpdj5cblxuICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IHZhbHVlIG9mIHZhbHVlQXJyYXk7IGluZGV4IGFzIGk7IHRyYWNrQnk6IHRyYWNrQnlSZW5kZXJlZFZhbHVlO1wiPlxuICAgICAgICA8aW5wdXQgW2NsYXNzXT1cIm1vZGVsLmNzc0NsYXNzZXMuaW5wdXRcIiBbYXR0ci5pZF09XCInc2pzLXNsaWRlci1pbnB1dC0nICsgaVwiIHR5cGU9XCJyYW5nZVwiIFt2YWx1ZV09XCJ2YWx1ZVwiIFxuICAgICAgICAgIFthdHRyLm1pbl09XCJtb2RlbC5taW5cIiBbYXR0ci5tYXhdPVwibW9kZWwubWF4XCIgW2F0dHIuc3RlcF09XCJtb2RlbC5zdGVwXCIgW2Rpc2FibGVkXT1cIm1vZGVsLmlzRGlzYWJsZWRBdHRyXCJcbiAgICAgICAgICAoaW5wdXQpPVwibW9kZWwuaGFuZGxlT25DaGFuZ2UoJGFueSgkZXZlbnQpLCBpKVwiXG4gICAgICAgICAgKHBvaW50ZXJkb3duKT1cIm1vZGVsLmhhbmRsZVBvaW50ZXJEb3duKCRhbnkoJGV2ZW50KSlcIlxuICAgICAgICAgIChwb2ludGVydXApPVwibW9kZWwuaGFuZGxlUG9pbnRlclVwKCRhbnkoJGV2ZW50KSlcIlxuICAgICAgICAgIChrZXlkb3duKT1cIm1vZGVsLmhhbmRsZUtleURvd24oJGFueSgkZXZlbnQpKVwiXG4gICAgICAgICAgKGtleXVwKT1cIm1vZGVsLmhhbmRsZUtleVVwKCRhbnkoJGV2ZW50KSlcIlxuICAgICAgICAgIChmb2N1cyk9XCJtb2RlbC5oYW5kbGVPbkZvY3VzKGkpXCJcbiAgICAgICAgICAoYmx1cik9XCJtb2RlbC5oYW5kbGVPbkJsdXIoKVwiXG4gICAgICAgICAgW2F0dHIuYXJpYS1yZXF1aXJlZF09XCJtb2RlbC5hMTF5X2lucHV0X2FyaWFSZXF1aXJlZFwiXG4gICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJtb2RlbC5hMTF5X2lucHV0X2FyaWFMYWJlbFwiXG4gICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cIm1vZGVsLmExMXlfaW5wdXRfYXJpYUxhYmVsbGVkQnlcIlxuICAgICAgICAgIFthdHRyLmFyaWEtZGVzY3JpYmVkYnldPVwibW9kZWwuYTExeV9pbnB1dF9hcmlhRGVzY3JpYmVkQnlcIlxuICAgICAgICAgIFthdHRyLmFyaWEtaW52YWxpZF09XCJtb2RlbC5hMTF5X2lucHV0X2FyaWFJbnZhbGlkXCJcbiAgICAgICAgICBbYXR0ci5hcmlhLWVycm9ybWVzc2FnZV09XCJtb2RlbC5hMTF5X2lucHV0X2FyaWFFcnJvcm1lc3NhZ2VcIlxuICAgICAgICAvPlxuICAgICAgICA8ZGl2IFtjbGFzc109XCJtb2RlbC5nZXRUaHVtYkNvbnRhaW5lckNzcyhpKVwiIFtzdHlsZV09XCJ7IGxlZnQ6IG1vZGVsLmdldFBlcmNlbnQodmFsdWUpICsgJyUnIH1cIj5cbiAgICAgICAgICA8ZGl2ICpuZ0lmPVwibW9kZWwudG9vbHRpcFZpc2liaWxpdHkgIT09ICduZXZlcidcIiBbY2xhc3NdPVwibW9kZWwudG9vbHRpcENzc1wiPlxuICAgICAgICAgICAgPGRpdiBbY2xhc3NdPVwibW9kZWwuY3NzQ2xhc3Nlcy50b29sdGlwUGFuZWxcIj5cbiAgICAgICAgICAgICAgPGRpdiBbY2xhc3NdPVwibW9kZWwuY3NzQ2xhc3Nlcy50b29sdGlwVmFsdWVcIj57e21vZGVsLmdldFRvb2x0aXBWYWx1ZShpKX19PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IFtjbGFzc109XCJtb2RlbC5jc3NDbGFzc2VzLnRodW1iXCI+XG4gICAgICAgICAgICA8ZGl2IFtjbGFzc109XCJtb2RlbC5jc3NDbGFzc2VzLnRodW1iRG90XCI+PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5cbiAgPGRpdiAqbmdJZj1cIm1vZGVsLnNob3dMYWJlbHNcIiBbY2xhc3NdPVwibW9kZWwuY3NzQ2xhc3Nlcy5sYWJlbHNDb250YWluZXJcIj5cbiAgICA8ZGl2PlxuICAgICAgPG5nLXRlbXBsYXRlICpuZ0Zvcj1cImxldCBsYWJlbCBvZiBtb2RlbC5yZW5kZXJlZExhYmVsczsgaW5kZXggYXMgaTsgdHJhY2tCeTogdHJhY2tCeUxhYmVsQ291bnQ7XCIgW2NvbXBvbmVudF09XCJ7IG5hbWU6ICdzdi1zbGlkZXItbGFiZWwtaXRlbScsIGRhdGE6IHttb2RlbDogbW9kZWwsIGl0ZW06IGxhYmVsIH19XCI+PC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cbiJdfQ==