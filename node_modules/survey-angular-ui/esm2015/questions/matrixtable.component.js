import { Component, Input } from "@angular/core";
import { BaseAngular } from "../base-angular";
import * as i0 from "@angular/core";
import * as i1 from "../survey-string.component";
import * as i2 from "./matrixrequiredheader.component";
import * as i3 from "./matrix-row.component";
import * as i4 from "./matrixdropdowncell.component";
import * as i5 from "@angular/common";
import * as i6 from "../utils/dynamic.directive";
export class MatrixTableComponent extends BaseAngular {
    getModel() {
        return this.table;
    }
    trackCellBy(_, cell) {
        return cell.id;
    }
    trackRowBy(index, row) {
        return row.id;
    }
}
MatrixTableComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: MatrixTableComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
MatrixTableComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: MatrixTableComponent, selector: "sv-ng-matrix-table", inputs: { question: "question", table: "table" }, usesInheritance: true, ngImport: i0, template: "<div #contentElement [class]=\"question.cssClasses.tableWrapper\">\n  <table [class]=\"question.getTableCss()\">\n    <thead *ngIf=\"table.showHeader\">\n      <tr>\n        <ng-container *ngFor=\"let cell of table.headerRow.cells; trackBy: trackCellBy\">\n          <th *ngIf=\"cell.hasTitle\" [class]=\"cell.className\" [style]=\"{ minWidth: cell.minWidth, width: cell.width }\">\n            <ng-template\n              [component]=\"{ name: question.getColumnHeaderWrapperComponentName($any(cell)), data: { componentData: question.getColumnHeaderWrapperComponentData($any(cell)) } }\">\n              <sv-ng-string [model]=\"cell.locTitle\"></sv-ng-string>\n              <sv-ng-matrixheaderrequired *ngIf=\"!!cell.column\" [column]=\"cell.column\" [question]=\"question\">\n              </sv-ng-matrixheaderrequired>\n            </ng-template>\n          </th>\n\n          <td *ngIf=\"!cell.hasTitle\" [class]=\"cell.className\" [style]=\"{ minWidth: cell.minWidth, width: cell.width }\">\n          </td>\n        </ng-container>\n      </tr>\n    </thead>\n    <tbody>\n      <ng-container *ngFor=\"let row of table.renderedRows; trackBy: trackRowBy\">\n        <sv-ng-matrix-row [model]=\"row\" [question]=\"question\"></sv-ng-matrix-row>\n      </ng-container>\n    </tbody>\n    <tfoot *ngIf=\"table.showFooter\">\n      <tr>\n        <sv-ng-matrixdropdown-cell [cell]=\"cell\" [question]=\"question\"\n          *ngFor=\"let cell of table.footerRow.cells; trackBy: trackCellBy\">\n        </sv-ng-matrixdropdown-cell>\n      </tr>\n    </tfoot>\n  </table>\n</div>", components: [{ type: i1.SurveyStringComponent, selector: "sv-ng-string, '[sv-ng-string]'", inputs: ["model"] }, { type: i2.MatrixRequiredHeader, selector: "sv-ng-matrixheaderrequired", inputs: ["column", "question"] }, { type: i3.MatrixRowComponent, selector: "sv-ng-matrix-row", inputs: ["model", "question"] }, { type: i4.MatrixDropdownCellComponent, selector: "sv-ng-matrixdropdown-cell", inputs: ["question", "cell"] }], directives: [{ type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i5.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i6.DynamicComponentDirective, selector: "[component]", inputs: ["component"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: MatrixTableComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "sv-ng-matrix-table",
                    templateUrl: "./matrixtable.component.html"
                }]
        }], propDecorators: { question: [{
                type: Input
            }], table: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0cml4dGFibGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3F1ZXN0aW9ucy9tYXRyaXh0YWJsZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi9zcmMvcXVlc3Rpb25zL21hdHJpeHRhYmxlLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2pELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQzs7Ozs7Ozs7QUFPOUMsTUFBTSxPQUFPLG9CQUFxQixTQUFRLFdBQWdEO0lBRzlFLFFBQVE7UUFDaEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCLENBQUM7SUFDTSxXQUFXLENBQUMsQ0FBUyxFQUFFLElBQVM7UUFDckMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDO0lBQ2pCLENBQUM7SUFDTSxVQUFVLENBQUMsS0FBYSxFQUFFLEdBQVE7UUFDdkMsT0FBTyxHQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hCLENBQUM7O2tIQVhVLG9CQUFvQjtzR0FBcEIsb0JBQW9CLG1JQ1JqQyw0aURBZ0NNOzRGRHhCTyxvQkFBb0I7a0JBSmhDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLG9CQUFvQjtvQkFDOUIsV0FBVyxFQUFFLDhCQUE4QjtpQkFDNUM7OEJBRVUsUUFBUTtzQkFBaEIsS0FBSztnQkFDRyxLQUFLO3NCQUFiLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IEJhc2VBbmd1bGFyIH0gZnJvbSBcIi4uL2Jhc2UtYW5ndWxhclwiO1xuaW1wb3J0IHsgUXVlc3Rpb25NYXRyaXhEcm9wZG93bk1vZGVsQmFzZSwgUXVlc3Rpb25NYXRyaXhEcm9wZG93blJlbmRlcmVkVGFibGUgfSBmcm9tIFwic3VydmV5LWNvcmVcIjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiBcInN2LW5nLW1hdHJpeC10YWJsZVwiLFxuICB0ZW1wbGF0ZVVybDogXCIuL21hdHJpeHRhYmxlLmNvbXBvbmVudC5odG1sXCJcbn0pXG5leHBvcnQgY2xhc3MgTWF0cml4VGFibGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlQW5ndWxhcjxRdWVzdGlvbk1hdHJpeERyb3Bkb3duUmVuZGVyZWRUYWJsZT4ge1xuICBASW5wdXQoKSBxdWVzdGlvbiE6IFF1ZXN0aW9uTWF0cml4RHJvcGRvd25Nb2RlbEJhc2U7XG4gIEBJbnB1dCgpIHRhYmxlITogUXVlc3Rpb25NYXRyaXhEcm9wZG93blJlbmRlcmVkVGFibGU7XG4gIHByb3RlY3RlZCBnZXRNb2RlbCgpOiBRdWVzdGlvbk1hdHJpeERyb3Bkb3duUmVuZGVyZWRUYWJsZSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGU7XG4gIH1cbiAgcHVibGljIHRyYWNrQ2VsbEJ5KF86IG51bWJlciwgY2VsbDogYW55KTogc3RyaW5nIHtcbiAgICByZXR1cm4gY2VsbC5pZDtcbiAgfVxuICBwdWJsaWMgdHJhY2tSb3dCeShpbmRleDogbnVtYmVyLCByb3c6IGFueSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHJvdy5pZDtcbiAgfVxufVxuIiwiPGRpdiAjY29udGVudEVsZW1lbnQgW2NsYXNzXT1cInF1ZXN0aW9uLmNzc0NsYXNzZXMudGFibGVXcmFwcGVyXCI+XG4gIDx0YWJsZSBbY2xhc3NdPVwicXVlc3Rpb24uZ2V0VGFibGVDc3MoKVwiPlxuICAgIDx0aGVhZCAqbmdJZj1cInRhYmxlLnNob3dIZWFkZXJcIj5cbiAgICAgIDx0cj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgY2VsbCBvZiB0YWJsZS5oZWFkZXJSb3cuY2VsbHM7IHRyYWNrQnk6IHRyYWNrQ2VsbEJ5XCI+XG4gICAgICAgICAgPHRoICpuZ0lmPVwiY2VsbC5oYXNUaXRsZVwiIFtjbGFzc109XCJjZWxsLmNsYXNzTmFtZVwiIFtzdHlsZV09XCJ7IG1pbldpZHRoOiBjZWxsLm1pbldpZHRoLCB3aWR0aDogY2VsbC53aWR0aCB9XCI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgW2NvbXBvbmVudF09XCJ7IG5hbWU6IHF1ZXN0aW9uLmdldENvbHVtbkhlYWRlcldyYXBwZXJDb21wb25lbnROYW1lKCRhbnkoY2VsbCkpLCBkYXRhOiB7IGNvbXBvbmVudERhdGE6IHF1ZXN0aW9uLmdldENvbHVtbkhlYWRlcldyYXBwZXJDb21wb25lbnREYXRhKCRhbnkoY2VsbCkpIH0gfVwiPlxuICAgICAgICAgICAgICA8c3Ytbmctc3RyaW5nIFttb2RlbF09XCJjZWxsLmxvY1RpdGxlXCI+PC9zdi1uZy1zdHJpbmc+XG4gICAgICAgICAgICAgIDxzdi1uZy1tYXRyaXhoZWFkZXJyZXF1aXJlZCAqbmdJZj1cIiEhY2VsbC5jb2x1bW5cIiBbY29sdW1uXT1cImNlbGwuY29sdW1uXCIgW3F1ZXN0aW9uXT1cInF1ZXN0aW9uXCI+XG4gICAgICAgICAgICAgIDwvc3YtbmctbWF0cml4aGVhZGVycmVxdWlyZWQ+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgIDwvdGg+XG5cbiAgICAgICAgICA8dGQgKm5nSWY9XCIhY2VsbC5oYXNUaXRsZVwiIFtjbGFzc109XCJjZWxsLmNsYXNzTmFtZVwiIFtzdHlsZV09XCJ7IG1pbldpZHRoOiBjZWxsLm1pbldpZHRoLCB3aWR0aDogY2VsbC53aWR0aCB9XCI+XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICA8L3RyPlxuICAgIDwvdGhlYWQ+XG4gICAgPHRib2R5PlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgcm93IG9mIHRhYmxlLnJlbmRlcmVkUm93czsgdHJhY2tCeTogdHJhY2tSb3dCeVwiPlxuICAgICAgICA8c3YtbmctbWF0cml4LXJvdyBbbW9kZWxdPVwicm93XCIgW3F1ZXN0aW9uXT1cInF1ZXN0aW9uXCI+PC9zdi1uZy1tYXRyaXgtcm93PlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC90Ym9keT5cbiAgICA8dGZvb3QgKm5nSWY9XCJ0YWJsZS5zaG93Rm9vdGVyXCI+XG4gICAgICA8dHI+XG4gICAgICAgIDxzdi1uZy1tYXRyaXhkcm9wZG93bi1jZWxsIFtjZWxsXT1cImNlbGxcIiBbcXVlc3Rpb25dPVwicXVlc3Rpb25cIlxuICAgICAgICAgICpuZ0Zvcj1cImxldCBjZWxsIG9mIHRhYmxlLmZvb3RlclJvdy5jZWxsczsgdHJhY2tCeTogdHJhY2tDZWxsQnlcIj5cbiAgICAgICAgPC9zdi1uZy1tYXRyaXhkcm9wZG93bi1jZWxsPlxuICAgICAgPC90cj5cbiAgICA8L3Rmb290PlxuICA8L3RhYmxlPlxuPC9kaXY+Il19