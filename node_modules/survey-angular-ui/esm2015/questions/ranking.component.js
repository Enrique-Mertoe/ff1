import { Component } from "@angular/core";
import { AngularComponentFactory } from "../component-factory";
import { SelectBaseComponent } from "./selectbase.component";
import * as i0 from "@angular/core";
import * as i1 from "../survey-string.component";
import * as i2 from "@angular/common";
import * as i3 from "../utils/dynamic.directive";
export class RankingQuestionComponent extends SelectBaseComponent {
    constructor() {
        super(...arguments);
        this.inputType = "";
        this.trackItemBy = (index, item) => {
            return item.value + "-" + index + "-item";
        };
    }
    getDefaultComponentName() {
        return "sv-ng-ranking-item";
    }
    getItemValueComponentData(item, index, unrankedItem) {
        const res = {
            componentName: this.getDefaultComponentName(),
            componentData: {
                question: this.model,
                model: item,
                inputType: this.inputType,
                data: this.model.getItemValueWrapperComponentData(item),
                index,
                unrankedItem
            }
        };
        return res;
    }
}
RankingQuestionComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: RankingQuestionComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
RankingQuestionComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: RankingQuestionComponent, selector: "sv-ng-ranking-question", usesInheritance: true, ngImport: i0, template: "<div *ngIf=\"!model.selectToRankEnabled\" [class]=\"model.rootClass\" #contentElement>\n  <ng-container *ngFor=\"let item of model.renderedRankingChoices; index as index; trackBy: trackItemBy\">\n    <ng-template [component]=\"{ name: getItemValueComponentName(item), data: getItemValueComponentData(item, index) }\"></ng-template>\n  </ng-container>\n</div>\n\n<div *ngIf=\"model.selectToRankEnabled\" [class]=\"model.rootClass\" #contentElement>\n  <div [class]='model.getContainerClasses(\"from\")' data-ranking=\"from-container\">\n    <ng-container *ngFor=\"let item of model.renderedUnRankingChoices; index as index; trackBy: trackItemBy\">\n      <ng-template [component]=\"{ name: getItemValueComponentName(item), data: getItemValueComponentData(item, index, true) }\"></ng-template>\n    </ng-container>\n\n    <div *ngIf=\"model.renderedUnRankingChoices.length === 0\" [class]=\"model.cssClasses.containerPlaceholder\" [model]=\"$any(model).locSelectToRankEmptyRankedAreaText\" sv-ng-string></div>\n  </div>\n\n  <div [class]=\"model.cssClasses.containersDivider\"></div>\n\n  <div [class]='model.getContainerClasses(\"to\")' data-ranking=\"to-container\">\n    <ng-container *ngFor=\"let item of model.renderedRankingChoices; index as index; trackBy: trackItemBy\">\n      <ng-template [component]=\"{ name: getItemValueComponentName(item), data: getItemValueComponentData(item, index) }\"></ng-template>\n    </ng-container>\n\n    <div *ngIf=\"model.renderedRankingChoices.length === 0\" [class]=\"model.cssClasses.containerPlaceholder\" [model]=\"$any(model).locSelectToRankEmptyUnrankedAreaText\" sv-ng-string></div>\n  </div>\n</div>", components: [{ type: i1.SurveyStringComponent, selector: "sv-ng-string, '[sv-ng-string]'", inputs: ["model"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.DynamicComponentDirective, selector: "[component]", inputs: ["component"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: RankingQuestionComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "sv-ng-ranking-question",
                    templateUrl: "./ranking.component.html",
                }]
        }] });
AngularComponentFactory.Instance.registerComponent("ranking-question", RankingQuestionComponent);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFua2luZy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcXVlc3Rpb25zL3JhbmtpbmcuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vc3JjL3F1ZXN0aW9ucy9yYW5raW5nLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFMUMsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDL0QsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7Ozs7O0FBTTdELE1BQU0sT0FBTyx3QkFBeUIsU0FBUSxtQkFBeUM7SUFKdkY7O1FBS2tCLGNBQVMsR0FBVyxFQUFFLENBQUM7UUFDOUIsZ0JBQVcsR0FBRyxDQUFDLEtBQWEsRUFBRSxJQUFlLEVBQVUsRUFBRTtZQUNoRSxPQUFPLElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxPQUFPLENBQUM7UUFDNUMsQ0FBQyxDQUFDO0tBa0JIO0lBakJpQix1QkFBdUI7UUFDckMsT0FBTyxvQkFBb0IsQ0FBQztJQUM5QixDQUFDO0lBQ2UseUJBQXlCLENBQUMsSUFBZSxFQUFFLEtBQWMsRUFBRSxZQUFzQjtRQUMvRixNQUFNLEdBQUcsR0FBRztZQUNWLGFBQWEsRUFBRSxJQUFJLENBQUMsdUJBQXVCLEVBQUU7WUFDN0MsYUFBYSxFQUFFO2dCQUNiLFFBQVEsRUFBRSxJQUFJLENBQUMsS0FBSztnQkFDcEIsS0FBSyxFQUFFLElBQUk7Z0JBQ1gsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTO2dCQUN6QixJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQyxJQUFJLENBQUM7Z0JBQ3ZELEtBQUs7Z0JBQ0wsWUFBWTthQUNiO1NBQ0YsQ0FBQztRQUNGLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQzs7c0hBckJVLHdCQUF3QjswR0FBeEIsd0JBQXdCLHFGQ1RyQyxtbkRBd0JNOzRGRGZPLHdCQUF3QjtrQkFKcEMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsd0JBQXdCO29CQUNsQyxXQUFXLEVBQUUsMEJBQTBCO2lCQUN4Qzs7QUF3QkQsdUJBQXVCLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLGtCQUFrQixFQUFFLHdCQUF3QixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgSXRlbVZhbHVlLCBRdWVzdGlvblJhbmtpbmdNb2RlbCB9IGZyb20gXCJzdXJ2ZXktY29yZVwiO1xuaW1wb3J0IHsgQW5ndWxhckNvbXBvbmVudEZhY3RvcnkgfSBmcm9tIFwiLi4vY29tcG9uZW50LWZhY3RvcnlcIjtcbmltcG9ydCB7IFNlbGVjdEJhc2VDb21wb25lbnQgfSBmcm9tIFwiLi9zZWxlY3RiYXNlLmNvbXBvbmVudFwiO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6IFwic3YtbmctcmFua2luZy1xdWVzdGlvblwiLFxuICB0ZW1wbGF0ZVVybDogXCIuL3JhbmtpbmcuY29tcG9uZW50Lmh0bWxcIixcbn0pXG5leHBvcnQgY2xhc3MgUmFua2luZ1F1ZXN0aW9uQ29tcG9uZW50IGV4dGVuZHMgU2VsZWN0QmFzZUNvbXBvbmVudDxRdWVzdGlvblJhbmtpbmdNb2RlbD4ge1xuICBwdWJsaWMgb3ZlcnJpZGUgaW5wdXRUeXBlOiBzdHJpbmcgPSBcIlwiO1xuICBvdmVycmlkZSB0cmFja0l0ZW1CeSA9IChpbmRleDogbnVtYmVyLCBpdGVtOiBJdGVtVmFsdWUpOiBzdHJpbmcgPT4ge1xuICAgIHJldHVybiBpdGVtLnZhbHVlICsgXCItXCIgKyBpbmRleCArIFwiLWl0ZW1cIjtcbiAgfTtcbiAgcHVibGljIG92ZXJyaWRlIGdldERlZmF1bHRDb21wb25lbnROYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFwic3YtbmctcmFua2luZy1pdGVtXCI7XG4gIH1cbiAgcHVibGljIG92ZXJyaWRlIGdldEl0ZW1WYWx1ZUNvbXBvbmVudERhdGEoaXRlbTogSXRlbVZhbHVlLCBpbmRleD86IG51bWJlciwgdW5yYW5rZWRJdGVtPzogYm9vbGVhbik6IGFueSB7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgY29tcG9uZW50TmFtZTogdGhpcy5nZXREZWZhdWx0Q29tcG9uZW50TmFtZSgpLFxuICAgICAgY29tcG9uZW50RGF0YToge1xuICAgICAgICBxdWVzdGlvbjogdGhpcy5tb2RlbCxcbiAgICAgICAgbW9kZWw6IGl0ZW0sXG4gICAgICAgIGlucHV0VHlwZTogdGhpcy5pbnB1dFR5cGUsXG4gICAgICAgIGRhdGE6IHRoaXMubW9kZWwuZ2V0SXRlbVZhbHVlV3JhcHBlckNvbXBvbmVudERhdGEoaXRlbSksXG4gICAgICAgIGluZGV4LFxuICAgICAgICB1bnJhbmtlZEl0ZW1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByZXM7XG4gIH1cbn1cbkFuZ3VsYXJDb21wb25lbnRGYWN0b3J5Lkluc3RhbmNlLnJlZ2lzdGVyQ29tcG9uZW50KFwicmFua2luZy1xdWVzdGlvblwiLCBSYW5raW5nUXVlc3Rpb25Db21wb25lbnQpOyIsIjxkaXYgKm5nSWY9XCIhbW9kZWwuc2VsZWN0VG9SYW5rRW5hYmxlZFwiIFtjbGFzc109XCJtb2RlbC5yb290Q2xhc3NcIiAjY29udGVudEVsZW1lbnQ+XG4gIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGl0ZW0gb2YgbW9kZWwucmVuZGVyZWRSYW5raW5nQ2hvaWNlczsgaW5kZXggYXMgaW5kZXg7IHRyYWNrQnk6IHRyYWNrSXRlbUJ5XCI+XG4gICAgPG5nLXRlbXBsYXRlIFtjb21wb25lbnRdPVwieyBuYW1lOiBnZXRJdGVtVmFsdWVDb21wb25lbnROYW1lKGl0ZW0pLCBkYXRhOiBnZXRJdGVtVmFsdWVDb21wb25lbnREYXRhKGl0ZW0sIGluZGV4KSB9XCI+PC9uZy10ZW1wbGF0ZT5cbiAgPC9uZy1jb250YWluZXI+XG48L2Rpdj5cblxuPGRpdiAqbmdJZj1cIm1vZGVsLnNlbGVjdFRvUmFua0VuYWJsZWRcIiBbY2xhc3NdPVwibW9kZWwucm9vdENsYXNzXCIgI2NvbnRlbnRFbGVtZW50PlxuICA8ZGl2IFtjbGFzc109J21vZGVsLmdldENvbnRhaW5lckNsYXNzZXMoXCJmcm9tXCIpJyBkYXRhLXJhbmtpbmc9XCJmcm9tLWNvbnRhaW5lclwiPlxuICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGl0ZW0gb2YgbW9kZWwucmVuZGVyZWRVblJhbmtpbmdDaG9pY2VzOyBpbmRleCBhcyBpbmRleDsgdHJhY2tCeTogdHJhY2tJdGVtQnlcIj5cbiAgICAgIDxuZy10ZW1wbGF0ZSBbY29tcG9uZW50XT1cInsgbmFtZTogZ2V0SXRlbVZhbHVlQ29tcG9uZW50TmFtZShpdGVtKSwgZGF0YTogZ2V0SXRlbVZhbHVlQ29tcG9uZW50RGF0YShpdGVtLCBpbmRleCwgdHJ1ZSkgfVwiPjwvbmctdGVtcGxhdGU+XG4gICAgPC9uZy1jb250YWluZXI+XG5cbiAgICA8ZGl2ICpuZ0lmPVwibW9kZWwucmVuZGVyZWRVblJhbmtpbmdDaG9pY2VzLmxlbmd0aCA9PT0gMFwiIFtjbGFzc109XCJtb2RlbC5jc3NDbGFzc2VzLmNvbnRhaW5lclBsYWNlaG9sZGVyXCIgW21vZGVsXT1cIiRhbnkobW9kZWwpLmxvY1NlbGVjdFRvUmFua0VtcHR5UmFua2VkQXJlYVRleHRcIiBzdi1uZy1zdHJpbmc+PC9kaXY+XG4gIDwvZGl2PlxuXG4gIDxkaXYgW2NsYXNzXT1cIm1vZGVsLmNzc0NsYXNzZXMuY29udGFpbmVyc0RpdmlkZXJcIj48L2Rpdj5cblxuICA8ZGl2IFtjbGFzc109J21vZGVsLmdldENvbnRhaW5lckNsYXNzZXMoXCJ0b1wiKScgZGF0YS1yYW5raW5nPVwidG8tY29udGFpbmVyXCI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaXRlbSBvZiBtb2RlbC5yZW5kZXJlZFJhbmtpbmdDaG9pY2VzOyBpbmRleCBhcyBpbmRleDsgdHJhY2tCeTogdHJhY2tJdGVtQnlcIj5cbiAgICAgIDxuZy10ZW1wbGF0ZSBbY29tcG9uZW50XT1cInsgbmFtZTogZ2V0SXRlbVZhbHVlQ29tcG9uZW50TmFtZShpdGVtKSwgZGF0YTogZ2V0SXRlbVZhbHVlQ29tcG9uZW50RGF0YShpdGVtLCBpbmRleCkgfVwiPjwvbmctdGVtcGxhdGU+XG4gICAgPC9uZy1jb250YWluZXI+XG5cbiAgICA8ZGl2ICpuZ0lmPVwibW9kZWwucmVuZGVyZWRSYW5raW5nQ2hvaWNlcy5sZW5ndGggPT09IDBcIiBbY2xhc3NdPVwibW9kZWwuY3NzQ2xhc3Nlcy5jb250YWluZXJQbGFjZWhvbGRlclwiIFttb2RlbF09XCIkYW55KG1vZGVsKS5sb2NTZWxlY3RUb1JhbmtFbXB0eVVucmFua2VkQXJlYVRleHRcIiBzdi1uZy1zdHJpbmc+PC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+Il19